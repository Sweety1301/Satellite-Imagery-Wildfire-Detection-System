# -*- coding: utf-8 -*-
"""Copy of Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11SPSYg6DUYEg_a_xEZZRo_38Ov9LDhw9
"""

import kagglehub

# Download latest version
path = kagglehub.dataset_download("abdelghaniaaba/wildfire-prediction-dataset")

print("Path to dataset files:", path)

import os
base_dir = f"{path}"
train_dir = os.path.join(base_dir, "train")
valid_dir = os.path.join(base_dir, "valid")
test_dir  = os.path.join(base_dir, "test")

# =====================================================
# üì¶ 2. Imports
# =====================================================
import numpy as np, gc, matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Dense, Dropout, GlobalAveragePooling2D, BatchNormalization
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.applications import ResNet152, InceptionV3
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, roc_curve, auc, accuracy_score

# =====================================================
# üß† 3. Data Generators (with Safe Image Loading)
# =====================================================
from PIL import ImageFile
ImageFile.LOAD_TRUNCATED_IMAGES = True  # üö® Ignore corrupted/truncated images

BATCH_SIZE = 16
train_datagen = ImageDataGenerator(
    rescale=1/255,
    rotation_range=25,
    width_shift_range=0.1,
    height_shift_range=0.1,
    zoom_range=0.1,
    horizontal_flip=True
)
valid_datagen = ImageDataGenerator(rescale=1/255)

train_gen = train_datagen.flow_from_directory(
    train_dir, target_size=(224,224),
    batch_size=BATCH_SIZE, class_mode='binary', shuffle=True
)
valid_gen = valid_datagen.flow_from_directory(
    valid_dir, target_size=(224,224),
    batch_size=BATCH_SIZE, class_mode='binary', shuffle=False
)
test_gen = valid_datagen.flow_from_directory(
    test_dir, target_size=(224,224),
    batch_size=BATCH_SIZE, class_mode='binary', shuffle=False
)

# =====================================================
# üß© 4. Fine-Tunable Model Builder
# =====================================================
def build_finetune_model(BaseModel, input_shape=(224,224,3)):
    base = BaseModel(weights='imagenet', include_top=False, input_shape=input_shape)

    # üîß Fine-tune last 30 layers
    for layer in base.layers[:-30]:
        layer.trainable = False
    for layer in base.layers[-30:]:
        layer.trainable = True

    model = Sequential([
        base,
        GlobalAveragePooling2D(),
        Dropout(0.4),
        Dense(256, activation='relu'),
        BatchNormalization(),
        Dropout(0.3),
        Dense(1, activation='sigmoid')
    ])
    model.compile(optimizer=Adam(1e-5), loss='binary_crossentropy', metrics=['accuracy'])
    return model

from tensorflow.keras import mixed_precision
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint
import tensorflow as tf, gc, os, time

# ‚úÖ Mixed precision for faster training
mixed_precision.set_global_policy('mixed_float16')
tf.config.optimizer.set_jit(True)

# ‚úÖ Training configuration
BATCH_SIZE = 16
input_shape = (224, 224, 3)
EPOCHS = 13

# üîπ Train ResNet152
print("\nüîπ Training ResNet152 ...")
start_time = time.time()

model = build_finetune_model(ResNet152, input_shape)
model.build(input_shape=(None,) + input_shape)

checkpoint = ModelCheckpoint("ResNet152_best.keras", monitor="val_accuracy", save_best_only=True, verbose=1)
lr_reduce  = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=2, verbose=1, min_lr=1e-7)
early_stop = EarlyStopping(monitor='val_loss', patience=4, restore_best_weights=True, verbose=1)

history = model.fit(
    train_gen,
    validation_data=valid_gen,
    epochs=EPOCHS,
    callbacks=[checkpoint, lr_reduce, early_stop],
    verbose=1
)

resnet_loss, resnet_acc = model.evaluate(test_gen, verbose=0)
resnet_time = (time.time() - start_time)/60
print(f"‚úÖ ResNet152 Test Accuracy: {resnet_acc*100:.2f}%  |  Time: {resnet_time:.1f} min")

os.makedirs("saved_models", exist_ok=True)
model.save("saved_models/ResNet152_model_full.keras")

del model
gc.collect()

# üîπ Train InceptionV3
print("\nüîπ Training InceptionV3 ...")
start_time = time.time()

model = build_finetune_model(InceptionV3, input_shape)
model.build(input_shape=(None,) + input_shape)

checkpoint = ModelCheckpoint("InceptionV3_best.keras", monitor="val_accuracy", save_best_only=True, verbose=1)
lr_reduce  = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=2, verbose=1, min_lr=1e-7)
early_stop = EarlyStopping(monitor='val_loss', patience=4, restore_best_weights=True, verbose=1)

history = model.fit(
    train_gen,
    validation_data=valid_gen,
    epochs=EPOCHS,
    callbacks=[checkpoint, lr_reduce, early_stop],
    verbose=1
)

inception_loss, inception_acc = model.evaluate(test_gen, verbose=0)
inception_time = (time.time() - start_time)/60
print(f"‚úÖ InceptionV3 Test Accuracy: {inception_acc*100:.2f}%  |  Time: {inception_time:.1f} min")

os.makedirs("saved_models", exist_ok=True)
model.save("saved_models/InceptionV3_model_full.keras")

del model
gc.collect()

from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, roc_curve, auc
import matplotlib.pyplot as plt

# üîç Evaluate ResNet152
print("\nüìà Evaluating ResNet152 ...")
model = load_model("saved_models/ResNet152_model_full.keras")

gen = ImageDataGenerator(rescale=1/255).flow_from_directory(
    test_dir, target_size=(224,224), batch_size=1, class_mode='binary', shuffle=False)

y_true = gen.classes
y_prob = model.predict(gen, verbose=0).ravel()
y_pred = (y_prob > 0.5).astype(int)

# üîπ Confusion Matrix
cm = confusion_matrix(y_true, y_pred)
ConfusionMatrixDisplay(cm, display_labels=list(gen.class_indices.keys())).plot(cmap="Blues")
plt.title("Confusion Matrix ‚Äì ResNet152")
plt.show()

# üîπ ROC Curve
fpr, tpr, _ = roc_curve(y_true, y_prob)
roc_auc = auc(fpr, tpr)
plt.plot(fpr, tpr, label=f"ResNet152 (AUC={roc_auc:.3f})")
plt.plot([0,1],[0,1],'--',color='gray')
plt.xlabel("False Positive Rate"); plt.ylabel("True Positive Rate")
plt.title("ROC Curve ‚Äì ResNet152"); plt.legend(); plt.show()

# üîç Evaluate InceptionV3
print("\nüìà Evaluating InceptionV3 ...")
model = load_model("saved_models/InceptionV3_model_full.keras")

gen = ImageDataGenerator(rescale=1/255).flow_from_directory(
    test_dir, target_size=(224,224), batch_size=1, class_mode='binary', shuffle=False)

y_true = gen.classes
y_prob = model.predict(gen, verbose=0).ravel()
y_pred = (y_prob > 0.5).astype(int)

# üîπ Confusion Matrix
cm = confusion_matrix(y_true, y_pred)
ConfusionMatrixDisplay(cm, display_labels=list(gen.class_indices.keys())).plot(cmap="Blues")
plt.title("Confusion Matrix ‚Äì InceptionV3")
plt.show()

# üîπ ROC Curve
fpr, tpr, _ = roc_curve(y_true, y_prob)
roc_auc = auc(fpr, tpr)
plt.plot(fpr, tpr, label=f"InceptionV3 (AUC={roc_auc:.3f})")
plt.plot([0,1],[0,1],'--',color='gray')
plt.xlabel("False Positive Rate"); plt.ylabel("True Positive Rate")
plt.title("ROC Curve ‚Äì InceptionV3"); plt.legend(); plt.show()

"""TESTING"""

import os
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# === Paths ===
model_path = "saved_models/ResNet152_model_full.keras"
test_image_path = "/root/.cache/kagglehub/datasets/abdelghaniaaba/wildfire-prediction-dataset/versions/1/test/wildfire/-59.03238,51.85132.jpg"  # change this if needed
classes = ["No Wildfire", "Wildfire"]
IMG_SIZE = (224, 224)

# === Load model ===
model = load_model(model_path)
print("‚úÖ Model loaded successfully.")

# === Determine true class from folder name ===
true_class_name = os.path.basename(os.path.dirname(test_image_path))
true_class_index = classes.index(true_class_name.title()) if true_class_name.lower() in ['wildfire','no wildfire'] else None

# === Load and preprocess the image ===
img = image.load_img(test_image_path, target_size=IMG_SIZE)
img_array = image.img_to_array(img) / 255.0
img_batch = np.expand_dims(img_array, axis=0)

# === Predict ===
pred_prob = model.predict(img_batch)[0][0]
pred_class_index = int(pred_prob > 0.5)
pred_class_name = classes[pred_class_index]
confidence = pred_prob if pred_class_index == 1 else (1 - pred_prob)

# === Check correctness ===
is_correct = (pred_class_index == true_class_index)

# === Display result ===
plt.imshow(img)
plt.axis("off")
plt.title(
    f"Predicted: {pred_class_name} ({confidence*100:.2f}%)\n"
    f"True Label: {true_class_name.title()}\n"
    f"‚úÖ Correct!" if is_correct else f"‚ùå Wrong Prediction!",
    fontsize=13,
    fontweight="bold",
    color="green" if is_correct else "red"
)
plt.show()

# === Print textual summary ===
print(f"True Label: {true_class_name.title()}")
print(f"Predicted: {pred_class_name} ({confidence*100:.2f}%)")
print(f"‚úÖ Correct!" if is_correct else f"‚ùå Wrong Prediction!")

import os
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# === Paths ===
model_path = "saved_models/ResNet152_model_full.keras"
test_image_path = "/root/.cache/kagglehub/datasets/abdelghaniaaba/wildfire-prediction-dataset/versions/1/test/nowildfire/-73.535,45.480806.jpg"  # change this if needed
classes = ["No Wildfire", "Wildfire"]
IMG_SIZE = (224, 224)

# === Load model ===
model = load_model(model_path)
print("‚úÖ Model loaded successfully.")

# === Determine true class from folder name ===
true_class_name = os.path.basename(os.path.dirname(test_image_path)).lower()

# Normalize naming
if "wildfire" in true_class_name:
    true_class_index = 1 if "no" not in true_class_name else 0
    true_class_name = classes[true_class_index]
else:
    true_class_index = None


# === Load and preprocess the image ===
img = image.load_img(test_image_path, target_size=IMG_SIZE)
img_array = image.img_to_array(img) / 255.0
img_batch = np.expand_dims(img_array, axis=0)

# === Predict ===
pred_prob = model.predict(img_batch)[0][0]
pred_class_index = int(pred_prob > 0.5)
pred_class_name = classes[pred_class_index]
confidence = pred_prob if pred_class_index == 1 else (1 - pred_prob)

# === Check correctness ===
is_correct = (pred_class_index == true_class_index)

# === Display result ===
plt.imshow(img)
plt.axis("off")
plt.title(
    f"Predicted: {pred_class_name} ({confidence*100:.2f}%)\n"
    f"True Label: {true_class_name.title()}\n"
    f"‚úÖ Correct!" if is_correct else f"‚ùå Wrong Prediction!",
    fontsize=13,
    fontweight="bold",
    color="green" if is_correct else "red"
)
plt.show()

# === Print textual summary ===
print(f"True Label: {true_class_name.title()}")
print(f"Predicted: {pred_class_name} ({confidence*100:.2f}%)")
print(f"‚úÖ Correct!" if is_correct else f"‚ùå Wrong Prediction!")

import os
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# === Paths ===
model_path = "saved_models/InceptionV3_model_full.keras"
test_image_path = "/root/.cache/kagglehub/datasets/abdelghaniaaba/wildfire-prediction-dataset/versions/1/test/nowildfire/-73.535,45.480806.jpg"  # change this if needed
classes = ["No Wildfire", "Wildfire"]
IMG_SIZE = (224, 224)

# === Load model ===
model = load_model(model_path)
print("‚úÖ Model loaded successfully.")

# === Determine true class from folder name ===
true_class_name = os.path.basename(os.path.dirname(test_image_path)).lower()

# Normalize naming
if "wildfire" in true_class_name:
    true_class_index = 1 if "no" not in true_class_name else 0
    true_class_name = classes[true_class_index]
else:
    true_class_index = None


# === Load and preprocess the image ===
img = image.load_img(test_image_path, target_size=IMG_SIZE)
img_array = image.img_to_array(img) / 255.0
img_batch = np.expand_dims(img_array, axis=0)

# === Predict ===
pred_prob = model.predict(img_batch)[0][0]
pred_class_index = int(pred_prob > 0.5)
pred_class_name = classes[pred_class_index]
confidence = pred_prob if pred_class_index == 1 else (1 - pred_prob)

# === Check correctness ===
is_correct = (pred_class_index == true_class_index)

# === Display result ===
plt.imshow(img)
plt.axis("off")
plt.title(
    f"Predicted: {pred_class_name} ({confidence*100:.2f}%)\n"
    f"True Label: {true_class_name.title()}\n"
    f"‚úÖ Correct!" if is_correct else f"‚ùå Wrong Prediction!",
    fontsize=13,
    fontweight="bold",
    color="green" if is_correct else "red"
)
plt.show()

# === Print textual summary ===
print(f"True Label: {true_class_name.title()}")
print(f"Predicted: {pred_class_name} ({confidence*100:.2f}%)")
print(f"‚úÖ Correct!" if is_correct else f"‚ùå Wrong Prediction!")

import os
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# === Paths ===
model_path = "saved_models/InceptionV3_model_full.keras"
test_image_path = "/root/.cache/kagglehub/datasets/abdelghaniaaba/wildfire-prediction-dataset/versions/1/test/wildfire/-59.03238,51.85132.jpg"  # change this if needed
classes = ["No Wildfire", "Wildfire"]
IMG_SIZE = (224, 224)

# === Load model ===
model = load_model(model_path)
print("‚úÖ Model loaded successfully.")

# === Determine true class from folder name ===
true_class_name = os.path.basename(os.path.dirname(test_image_path))
true_class_index = classes.index(true_class_name.title()) if true_class_name.lower() in ['wildfire','no wildfire'] else None

# === Load and preprocess the image ===
img = image.load_img(test_image_path, target_size=IMG_SIZE)
img_array = image.img_to_array(img) / 255.0
img_batch = np.expand_dims(img_array, axis=0)

# === Predict ===
pred_prob = model.predict(img_batch)[0][0]
pred_class_index = int(pred_prob > 0.5)
pred_class_name = classes[pred_class_index]
confidence = pred_prob if pred_class_index == 1 else (1 - pred_prob)

# === Check correctness ===
is_correct = (pred_class_index == true_class_index)

# === Display result ===
plt.imshow(img)
plt.axis("off")
plt.title(
    f"Predicted: {pred_class_name} ({confidence*100:.2f}%)\n"
    f"True Label: {true_class_name.title()}\n"
    f"‚úÖ Correct!" if is_correct else f"‚ùå Wrong Prediction!",
    fontsize=13,
    fontweight="bold",
    color="green" if is_correct else "red"
)
plt.show()

# === Print textual summary ===
print(f"True Label: {true_class_name.title()}")
print(f"Predicted: {pred_class_name} ({confidence*100:.2f}%)")
print(f"‚úÖ Correct!" if is_correct else f"‚ùå Wrong Prediction!")

import pandas as pd

results = [
    {"Model": "ResNet152", "Accuracy": resnet_acc*100, "Time (min)": resnet_time},
    {"Model": "InceptionV3", "Accuracy": inception_acc*100, "Time (min)": inception_time},
]
pd.DataFrame(results)

plt.figure(figsize=(10,5))
plt.plot(history.history['accuracy'], label='Train Acc')
plt.plot(history.history['val_accuracy'], label='Val Acc')
plt.title('Training vs Validation Accuracy')
plt.legend()
plt.show()

import tensorflow as tf
from tensorflow.keras.applications import ResNet152, InceptionV3
from tensorflow.keras.layers import GlobalAveragePooling2D, Concatenate, Dense, Dropout, Input
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam

# === Hybrid Model Definition ===
def build_hybrid_resincept(input_shape=(224, 224, 3)):
    input_tensor = Input(shape=input_shape)

    # Base 1: ResNet152
    resnet_base = ResNet152(weights='imagenet', include_top=False, input_tensor=input_tensor)
    for layer in resnet_base.layers[:-30]:
        layer.trainable = False

    # Base 2: InceptionV3
    inception_base = InceptionV3(weights='imagenet', include_top=False, input_tensor=input_tensor)
    for layer in inception_base.layers[:-30]:
        layer.trainable = False

    # Feature extraction and fusion
    res_features = GlobalAveragePooling2D()(resnet_base.output)
    inc_features = GlobalAveragePooling2D()(inception_base.output)

    merged = Concatenate()([res_features, inc_features])
    x = Dense(512, activation='relu')(merged)
    x = Dropout(0.4)(x)
    x = Dense(256, activation='relu')(x)
    x = Dropout(0.3)(x)
    output = Dense(1, activation='sigmoid')(x)

    model = Model(inputs=input_tensor, outputs=output, name="Hybrid_ResIncepNet")
    model.compile(optimizer=Adam(learning_rate=1e-5), loss='binary_crossentropy', metrics=['accuracy'])
    return model

# === Build Model ===
hybrid_model = build_hybrid_resincept()
hybrid_model.summary()

from tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau

checkpoint = ModelCheckpoint("saved_models/Hybrid_ResIncepNet_best.keras", monitor="val_accuracy", save_best_only=True, verbose=1)
early_stop = EarlyStopping(monitor='val_loss', patience=4, restore_best_weights=True, verbose=1)
lr_reduce = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=2, verbose=1, min_lr=1e-7)

history = hybrid_model.fit(
    train_gen,
    validation_data=valid_gen,
    epochs=10,
    callbacks=[checkpoint, early_stop, lr_reduce],
    verbose=1
)

# Save final model
hybrid_model.save("saved_models/Hybrid_ResIncepNet_full.keras")

# Evaluate on test set
loss, acc = hybrid_model.evaluate(test_gen, verbose=0)
print(f"‚úÖ Hybrid Model Test Accuracy: {acc*100:.2f}%")

import matplotlib.pyplot as plt
import numpy as np

# ==========================
# üîπ Model Performance Data
# ==========================
models = ['ResNet152', 'InceptionV3', 'Hybrid_ResIncepNet']

# Replace these with your actual results
accuracies = [94.25, 97.25, 97.29]       # in %
training_times = [93.8, 83.6, 80.29]   # in minutes (example values)

# ==========================
# üîπ Bar Chart ‚Äì Accuracy Comparison
# ==========================
plt.figure(figsize=(8, 5))
bars = plt.bar(models, accuracies, color=['skyblue', 'lightgreen', 'gold'])

# Annotate each bar
for bar, acc in zip(bars, accuracies):
    plt.text(bar.get_x() + bar.get_width() / 2, bar.get_height() + 0.2, f'{acc:.1f}%',
             ha='center', va='bottom', fontsize=11, fontweight='bold')

plt.title('Model Accuracy Comparison', fontsize=16, fontweight='bold')
plt.ylabel('Accuracy (%)', fontsize=13)
plt.ylim(90, 100)
plt.grid(axis='y', linestyle='--', alpha=0.6)
plt.show()

# ==========================
# üîπ Bar Chart ‚Äì Training Time Comparison
# ==========================
plt.figure(figsize=(8, 5))
bars = plt.bar(models, training_times, color=['lightcoral', 'orange', 'mediumseagreen'])

# Annotate bars
for bar, t in zip(bars, training_times):
    plt.text(bar.get_x() + bar.get_width() / 2, bar.get_height() + 0.2, f'{t:.1f} min',
             ha='center', va='bottom', fontsize=11, fontweight='bold')

plt.title('Model Training Time Comparison', fontsize=16, fontweight='bold')
plt.ylabel('Training Time (minutes)', fontsize=13)
plt.grid(axis='y', linestyle='--', alpha=0.6)
plt.show()

import os
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# === Paths ===
model_path = "saved_models/Hybrid_ResIncepNet_best.keras"
test_image_path = "/root/.cache/kagglehub/datasets/abdelghaniaaba/wildfire-prediction-dataset/versions/1/test/wildfire/-59.03238,51.85132.jpg"  # change this if needed
classes = ["No Wildfire", "Wildfire"]
IMG_SIZE = (224, 224)

# === Load model ===
model = load_model(model_path)
print("‚úÖ Model loaded successfully.")

# === Determine true class from folder name ===
true_class_name = os.path.basename(os.path.dirname(test_image_path))
true_class_index = classes.index(true_class_name.title()) if true_class_name.lower() in ['wildfire','no wildfire'] else None

# === Load and preprocess the image ===
img = image.load_img(test_image_path, target_size=IMG_SIZE)
img_array = image.img_to_array(img) / 255.0
img_batch = np.expand_dims(img_array, axis=0)

# === Predict ===
pred_prob = model.predict(img_batch)[0][0]
pred_class_index = int(pred_prob > 0.5)
pred_class_name = classes[pred_class_index]
confidence = pred_prob if pred_class_index == 1 else (1 - pred_prob)

# === Check correctness ===
is_correct = (pred_class_index == true_class_index)

# === Display result ===
plt.imshow(img)
plt.axis("off")
plt.title(
    f"Predicted: {pred_class_name} ({confidence*100:.2f}%)\n"
    f"True Label: {true_class_name.title()}\n"
    f"‚úÖ Correct!" if is_correct else f"‚ùå Wrong Prediction!",
    fontsize=13,
    fontweight="bold",
    color="green" if is_correct else "red"
)
plt.show()

# === Print textual summary ===
print(f"True Label: {true_class_name.title()}")
print(f"Predicted: {pred_class_name} ({confidence*100:.2f}%)")
print(f"‚úÖ Correct!" if is_correct else f"‚ùå Wrong Prediction!")

import os
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import load_model

# === Paths ===
model_path = "saved_models/Hybrid_ResIncepNet_best.keras"
test_image_path = "/root/.cache/kagglehub/datasets/abdelghaniaaba/wildfire-prediction-dataset/versions/1/test/nowildfire/-73.62263,45.413016.jpg"
classes = ["No Wildfire", "Wildfire"]
IMG_SIZE = (224, 224)

# === Load model ===
model = load_model(model_path)
print("‚úÖ Model loaded successfully.")

# === Determine true class name from folder ===
true_class_folder = os.path.basename(os.path.dirname(test_image_path)).lower()

if "wildfire" in true_class_folder:
    true_class_index = 1 if "no" not in true_class_folder else 0
    true_class_name = classes[true_class_index]
else:
    true_class_index = None
    true_class_name = "Unknown"

# === Load and preprocess image ===
img = image.load_img(test_image_path, target_size=IMG_SIZE)
img_array = image.img_to_array(img) / 255.0
img_batch = np.expand_dims(img_array, axis=0)

# === Predict ===
pred_prob = model.predict(img_batch, verbose=0)[0][0]
pred_class_index = int(pred_prob > 0.5)
pred_class_name = classes[pred_class_index]
confidence = pred_prob if pred_class_index == 1 else (1 - pred_prob)

# === Check correctness ===
is_correct = (pred_class_index == true_class_index)

# === Display image and result ===
plt.imshow(img)
plt.axis("off")
plt.title(
    f"Predicted: {pred_class_name} ({confidence*100:.2f}%)\n"
    f"True Label: {true_class_name}\n"
    f"{'‚úÖ Correct Prediction!' if is_correct else '‚ùå Wrong Prediction!'}",
    fontsize=13,
    fontweight="bold",
    color="green" if is_correct else "red"
)
plt.show()

# === Print textual summary ===
print("üîç Prediction Summary:")
print(f"True Label     : {true_class_name}")
print(f"Predicted Label: {pred_class_name} ({confidence*100:.2f}%)")
print("‚úÖ Correct!" if is_correct else "‚ùå Wrong Prediction!")

import matplotlib.pyplot as plt
import numpy as np

# =======================================
# üìä Accuracy Data
# =======================================
papers = [
    "Aarich et al. (2024)\nMDCNN",
    "Castro et al. (2023)\nMTL",
    "Zheng et al. (2024)\nMDCNN",
    "Sathishkumar et al. (2023)\nXception + LwF",
    "Our Work\n(ResNet152)",
    "Our Work\n(InceptionV3)",
    "Our Work\n(Hybrid ResIncepNet)"
]

accuracies = [95.8, 90.7, 95.8, 96.7, 94.5, 97.0, 97.6]

# =======================================
# üé® Plotting
# =======================================
plt.figure(figsize=(12,6))
colors = ['lightgray', 'lightgray', 'lightgray', 'lightgray', '#5DADE2', '#48C9B0', '#F4D03F']

bars = plt.bar(papers, accuracies, color=colors, edgecolor='black')

# Annotate bars
for bar, acc in zip(bars, accuracies):
    plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.3, f'{acc:.1f}%',
             ha='center', va='bottom', fontsize=11, fontweight='bold')

# =======================================
# üßæ Styling
# =======================================
plt.title("Accuracy Comparison: Existing Research vs Proposed Model", fontsize=16, fontweight='bold')
plt.ylabel("Accuracy (%)", fontsize=13)
plt.ylim(85, 100)
plt.xticks(rotation=20, ha='right', fontsize=11)
plt.grid(axis='y', linestyle='--', alpha=0.5)

# Legend
plt.legend(["Existing Works", "Our Models"], loc='lower right')

plt.tight_layout()
plt.show()